#!/usr/bin/python
# -*- coding: utf-8 -*-

from __future__ import unicode_literals
import argparse
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as pl
import matplotlib.gridspec
from photon_tools.io import read_photons
from photon_tools.bin_photons import bin_photons
from photon_tools import correlate
from photon_tools.fcs_models import *
from scipy.stats import linregress
import squmfit

parser = argparse.ArgumentParser()
parser.add_argument('file', nargs='+', type=argparse.FileType('r'), help='Timestamp file')
args = parser.parse_args()

large_bin = 1 # second
small_bin = 2e-3 # second
small_length = 1 # second
engine = 'favia'

for f in args.file:
    ts = read_photons.open(f.name)
    print '%s:' % (f.name)
    print '    jiffy = %g ns' % (ts.jiffy / 1e-9)

    fig = pl.figure(figsize=(8.0, 10.5))
    gs = matplotlib.gridspec.GridSpec(5, 3)
    fig.suptitle(f.name)

    small_traj_plt = pl.subplot(gs[1, 0])
    small_traj_plt.set_ylabel('counts per %g sec' % small_bin)
    small_traj_plt.locator_params(nbins=3)
    large_traj_plt = pl.subplot(gs[1, 1:2])
    large_traj_plt.set_ylabel('counts per %g sec' % large_bin)
    large_traj_plt.locator_params(nbins=3)

    corr_plt = pl.subplot(gs[2, 0:2])
    resid_plt = pl.subplot(gs[3, 0:2])
    corr_plt.set_xscale('log')
    resid_plt.set_xscale('log')

    pch_plt = pl.subplot(gs[1, 2])
    pch_plt.locator_params(nbins=3)
    pch_plt.set_xlabel('photons per %g sec' % small_bin)
    pch_plt.set_ylabel('events')

    text = "jiffy = %g ns\n" % (ts.jiffy / 1e-9)
    for c in ts.valid_channels:
        d = None
        try:
            d = ts.channel(c)
        except Exception as e:
            print 'Error reading timestamps for channel %d: %s' % (c, e)
            continue

        N = len(d)
        if N == 0:
            continue
        dur = d[-1] - d[0]
        dur *= ts.jiffy
        bins = bin_photons(d, large_bin / ts.jiffy)
        m, b, r, p, stderr = linregress(bins['start_t'], bins['count'])

        text += '    channel %s: T=%1.1f seconds, N=%1.2e\n' % (c, dur, N)
        text += '        rate = %1.1f Hz, std dev = %1.1f Hz\n' % (N / dur, np.std(bins['count']))
        text += '        dI/dt = %g Â± %1.1g Hz / second\n' % (m / ts.jiffy, stderr / ts.jiffy)
        text += '\n'

        large_traj_plt.plot(bins['start_t'] * ts.jiffy, bins['count'])

        middle = (d[-1] - d[0]) // 2 + d[0]
        bins = bin_photons(d, small_bin / ts.jiffy, start_t=middle, end_t=middle + 1/ts.jiffy)
        small_traj_plt.plot(bins['start_t'] * ts.jiffy, bins['count'])

        try:
            g = correlate.autocorr(d, jiffy=ts.jiffy, min_lag=5e-7, max_lag=min(dur/15, 10), engine=engine)
            corr_plt.errorbar(g['lag'], g['G'], fmt='+', yerr=np.sqrt(g['var']), label='ch%d' % c)
        except Exception as e:
            print 'Failed to compute autocorrelation for channel %d: %s' % (c, e)

        pch = bin_photons(d, small_bin / ts.jiffy, include_zeros=False)
        upper = None # 1e5 * small_bin
        pch_plt.hist(pch['count'], normed=True, range=(0, upper), bins=int(1e4 * small_bin),
                     histtype='step')

    large_traj_plt.autoscale(axis='both', tight=True)
    small_traj_plt.autoscale(axis='both', tight=True)

    ((x,y), _) = gs[0,0].get_position(fig).get_points()
    fig.text(x, y, text)

    # Cross-correlation
    try:
        g = correlate.corr(ts.channel(0), ts.channel(1),
                           jiffy=ts.jiffy, min_lag=100e-9, max_lag=min(dur/15, 10), engine=engine)
        corr_plt.errorbar(g['lag'], g['G'], fmt='+', yerr=np.sqrt(g['var']), label='xcorr')


        handles, labels = corr_plt.get_legend_handles_labels()
        fig.legend(handles=handles, labels=labels,
                   loc='upper left',
                   bbox_to_anchor= gs[2,2].get_position(fig),
                   bbox_transform=fig.transFigure,
                   mode='expand', fontsize='small', ncol=1, frameon=False)

        # Plot
        fit = squmfit.Fit()
        aspect = 10
        triplet = True
        offset = True
        lifetimes = [fit.param('tauD-%d' % i, initial=initial)
                     for i,initial in enumerate([100, 1000])]
        lag = squmfit.Argument('lag')
        model = 0 if not offset else fit.param('offset', 0)
        model += 1
        for comp_idx, tauD in enumerate(lifetimes):
            n = fit.param('N-%d' % (comp_idx), initial=1. / g[-1]['G'] / len(lifetimes))
            model += three_dim_diffusion(lag=lag, tauD=1e-6 * tauD, aspect=aspect, n=n, alpha=1)
        if triplet:
            tauF = fit.param('tauF', initial=0.5)
            model *= triplet_correction(lag=lag, tauF=1e-6 * tauF,
                                        tripletFrac=fit.param('F', initial=0))

        g = g[np.logical_not(np.isnan(g['var']))] # FIXME
        fit.add_curve('curve', model, g['G'], weights=1/np.maximum(1e-5, sqrt(g['var'])), lag=g['lag'])
        res = fit.fit()
        corr_plt.plot(g['lag'], res.curves['curve'].fit)
        corr_plt.axhline(1, c='k')
        pl.setp(corr_plt.get_xticklabels(), visible=False)
        resid_plt.plot(g['lag'], res.curves['curve'].residuals, '+')
        resid_plt.axhline(0, c='k')
        resid_plt.set_xlabel(r'$\tau$ (microseconds)')
        corr_plt.set_ylabel(r'$G(\tau)$')

        ((x,y), _) = gs[4,0].get_position(fig).get_points()
        text = 'reduced $\\chi^2$ = %f\n' % res.curves['curve'].reduced_chi_sqr
        text += '\n'.join('%15s = %4f' % (param.name, res.eval(param))
                          for param in res.fit.param_set.params.values())
        fig.text(x, y, text, fontsize='small')
    except Exception as e:
        print 'failed to compute cross-correlation: %s' % e

    pl.savefig(f.name+'.summary.svg')

    print
