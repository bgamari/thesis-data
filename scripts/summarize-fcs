#!/usr/bin/python
# -*- coding: utf-8 -*-

from __future__ import unicode_literals
import argparse
import numpy as np
import matplotlib.pyplot as pl
import matplotlib.gridspec
import matplotlib
matplotlib.use('Agg')
from photon_tools.io import read_photons
from photon_tools.bin_photons import bin_photons
from photon_tools import correlate
from photon_tools.fcs_models import *
from scipy.stats import linregress
import squmfit

parser = argparse.ArgumentParser()
parser.add_argument('file', nargs='+', type=argparse.FileType('r'), help='Timestamp file')
args = parser.parse_args()

large_bin = 1 # second
small_bin = 1e-3 # second
small_length = 1 # second
engine = 'favia'

for f in args.file:
    ts = read_photons.open(f.name)
    print '%s:' % (f.name)
    print '    jiffy = %g ns' % (ts.jiffy / 1e-9)

    fig = pl.figure(figsize=(8.0, 10.5))
    gs = matplotlib.gridspec.GridSpec(5, 3)
    fig.suptitle(f.name)

    small_traj_plt = pl.subplot(gs[1, 0])
    large_traj_plt = pl.subplot(gs[1, 1:2])
    corr_plt = pl.subplot(gs[2, 0:2])
    resid_plt = pl.subplot(gs[3, 0:2])
    corr_plt.set_xscale('log')
    resid_plt.set_xscale('log')

    text = "jiffy = %g ns\n" % (ts.jiffy / 1e-9)
    for c in ts.valid_channels:
        d = ts.channel(c)
        N = len(d)
        if N == 0:
            continue
        dur = d[-1] - d[0]
        dur *= ts.jiffy
        bins = bin_photons(d, large_bin / ts.jiffy)
        m, b, r, p, stderr = linregress(bins['start_t'], bins['count'])

        print '    channel %s: T=%1.1f seconds, N=%1.2e' % (c, dur, N)
        print '        rate = %1.1f Hz, variance = %1.1f Hz²' % (N / dur, np.var(bins['count']))
        print '        dI/dt = %g ± %1.1g Hz / second' % (m / ts.jiffy, stderr / ts.jiffy)

        text += '    channel %s: T=%1.1f seconds, N=%1.2e\n' % (c, dur, N)
        text += '        rate = %1.1f Hz, variance = %1.1f Hz²\n' % (N / dur, np.var(bins['count']))
        text += '        dI/dt = %g ± %1.1g Hz / second\n' % (m / ts.jiffy, stderr / ts.jiffy)
        text += '\n'

        large_traj_plt.plot(bins['start_t'] * ts.jiffy, bins['count'])

        middle = (d[-1] - d[0]) // 2 + d[0]
        bins = bin_photons(d, small_bin / ts.jiffy, start_t=middle, end_t=middle + 1/ts.jiffy)
        small_traj_plt.plot(bins['start_t'] * ts.jiffy, bins['count'])

        g = correlate.autocorr(d, jiffy=ts.jiffy, min_lag=5e-7, max_lag=min(dur/15, 10), engine=engine)
        corr_plt.errorbar(g['lag'], g['G'], fmt='+', yerr=np.sqrt(g['var']))

    ((x,y), _) = gs[0,0].get_position(fig).get_points()
    fig.text(x, y, text)

    # Cross-correlation
    g = correlate.corr(ts.channel(0), ts.channel(1),
                       jiffy=ts.jiffy, min_lag=100e-9, max_lag=min(dur/15, 10), engine=engine)
    corr_plt.errorbar(g['lag'], g['G'], fmt='+', yerr=np.sqrt(g['var']))

    # Plot
    fit = squmfit.Fit()
    aspect = 10
    triplet = True
    offset = True
    lifetimes = [fit.param('tauD-%d' % i, initial=initial)
                 for i,initial in enumerate([100, 400])]
    lag = squmfit.Argument('lag')
    model = 0 if not offset else fit.param('offset', 0)
    model += 1
    for comp_idx, tauD in enumerate(lifetimes):
        n = fit.param('N-%d' % (comp_idx), initial=10)
        model += three_dim_diffusion(lag=lag, tauD=1e-6 * tauD, aspect=aspect, n=n, alpha=1)
    if triplet:
        tauF = fit.param('tauF', initial=0.5)
        model *= triplet_correction(lag=lag, tauF=1e-6 * tauF,
                                    tripletFrac=fit.param('F', initial=0))

    g = g[np.logical_not(np.isnan(g['var']))] # FIXME
    fit.add_curve('curve', model, g['G'], weights=1/np.maximum(1e-5, sqrt(g['var'])), lag=g['lag'])
    res = fit.fit()
    corr_plt.plot(g['lag'], res.curves['curve'].fit)
    corr_plt.axhline(1, c='k')
    pl.setp(corr_plt.get_xticklabels(), visible=False)
    resid_plt.plot(g['lag'], res.curves['curve'].residuals, '+')
    resid_plt.axhline(0, c='k')
    resid_plt.set_xlabel(r'$\tau$ (microseconds)')
    corr_plt.set_ylabel(r'$G(\tau)$')

    ((x,y), _) = gs[4,0].get_position(fig).get_points()
    text = '$\\chi^2$ = %f\n' % res.curves['curve'].chi_sqr
    text += '\n'.join('%15s = %4f' % (param.name, res.eval(param))
                      for param in res.fit.param_set.params.values())
    fig.text(x, y, text)

    pl.savefig(f.name+'.summary.svg')

    print
